export const metadata = {
  title: 'Race Conditions in Django: A Comprehensive Guide',
  description:
    'Learn how to identify, prevent, and solve race conditions in Django applications. From database-level solutions to distributed locking, this guide covers everything you need to build reliable concurrent systems.',
  alternates: {
    canonical: '/blog/exploring-the-intersection-of-design-ai-and-design-engineering',
  },
};

<Cover
  src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwkaQxhREF7qg_clkX6biw.jpeg"
  alt="Race conditions in concurrent systems - from medium.com"
  caption="medium.com"
/>

# Race Conditions in Django: A Comprehensive Guide

Concurrency is an inevitable reality in modern web applications. When multiple users interact with the system simultaneously, race conditions can arise. Let's explore how to manage and solve these situations in the Django framework.

---

## What Will You Learn in This Article?

- Fundamentals of race conditions and how they occur
- The most common race condition scenarios in Django
- Database-level and application-level solution strategies
- SELECT FOR UPDATE, F() expressions, distributed locking techniques
- Asynchronous operations with Celery
- Performance impact analysis, deadlock scenarios, and best practices

---

## Why Is This Topic Important?

Today's web applications are no longer single-user systems. Platforms like social media, e-commerce sites, and financial applications have thousands of users acting at the same time. This creates major challenges for data consistency and system reliability.

Race conditions can:
- Cause data loss
- Create system inconsistencies
- Lead to security vulnerabilities
- Disrupt user experience
- Cause financial losses

---

<img 
  src="/race1.jpg" 
  alt="Race condition illustration showing concurrent operations" 
  className="w-full max-w-md mx-auto rounded-lg shadow-lg my-8"
/>

## What Is a Race Condition?

A race condition is a software bug that occurs when two or more operations try to access the same resource at the same time, and the order of these operations affects the outcome.

### Real-World Example: Bank Money Transfer

Imagine two users trying to transfer money from the same bank account at the same time. If both check the balance, see enough funds, and then both withdraw, the account can be overdrawn or the balance can become inconsistent.

```python
# Vulnerable bank transfer (race condition!)
def transfer_money(account, amount):
    if account.balance >= amount:
        account.balance -= amount
        account.save()
        # ... send money ...
```

If two transfers run at the same time, both may see enough balance and both may withdraw, causing the account to go negative or lose money.

---

## How Do Race Conditions Occur?

Race conditions typically arise in the following situations:

- **Read-Modify-Write Pattern**: When read, modify, and write operations are not atomic
- **Check-Then-Act Pattern**: Time gap between checking and acting
- **Resource Sharing**: Concurrent access to the same resource
- **Timing Dependencies**: Results depend on the timing of operations

### A Simple Example: The Counter Problem

```python
# Code vulnerable to race condition
def increment_counter():
    counter = Counter.objects.get(id=1)
    counter.value += 1
    counter.save()
```

If two users call `increment_counter()` at the same time:

**Timeline:**
- Time: 0ms - User A: `counter = Counter.objects.get(id=1)` # counter.value = 5
- Time: 1ms - User B: `counter = Counter.objects.get(id=1)` # counter.value = 5 (still!)
- Time: 2ms - User A: `counter.value += 1` # counter.value = 6
- Time: 3ms - User B: `counter.value += 1` # counter.value = 6 (doesn't see User A's change!)
- Time: 4ms - User A: `counter.save()` # DB saved as 6
- Time: 5ms - User B: `counter.save()` # DB saved as 6 (overwrites User A's change!)

**Result**: Should be 5 + 1 + 1 = 7, but ends up as 6. One increment is lost!

---

<img 
  src="/race2.jpg" 
  alt="Django race condition scenarios illustration" 
  className="w-full max-w-2xl mx-auto rounded-lg shadow-lg my-8"
/>

## Race Condition Scenarios in Django

Race conditions in Django projects typically occur in the following areas:

### 1. Counter Updates

A real project example: User follow system:

```python
# Code vulnerable to race condition
def follow(self, user):
    self.follows.add(user)
    self.followed_number += 1  # Race condition!
    user.follower_number += 1  # Race condition!
    self.save()
    user.save()
```

**Problem Analysis:**
- `followed_number` and `follower_number` fields are vulnerable to race conditions
- If two users follow at the same time, counters may be updated incorrectly
- Many-to-many relation (`follows.add()`) is atomic, but counter updates are not

### 2. Unique Field Checks

A common scenario in user registration:

```python
# Code vulnerable to race condition
def create_user(username, email):
    if User.objects.filter(username=username).exists():
        raise ValidationError("Username already exists")
    
    if User.objects.filter(email=email).exists():
        raise ValidationError("Email already exists")
    
    # At this point, another process could register with the same username/email
    user = User.objects.create(username=username, email=email)
    return user
```

**Problem**: If two users try to register with the same username at the same time, both may succeed!

### 3. Financial Transactions

One of the most critical race condition scenarios:

```python
# Vulnerable money transfer
def transfer_money(from_account, to_account, amount):
    if from_account.balance >= amount:
        from_account.balance -= amount
        to_account.balance += amount
        
        from_account.save()
        to_account.save()
        
        Transaction.objects.create(
            from_account=from_account,
            to_account=to_account,
            amount=amount
        )
        return "Transfer successful"
    else:
        return "Insufficient funds"
```

**Problem**: If multiple transfers happen at the same time, balance inconsistencies can occur!

---

## Solutions to Race Conditions in Django

We can use different approaches at different levels to solve race conditions.

### 1. Database-Level Solutions

#### A. SELECT FOR UPDATE (Pessimistic Locking)

This method locks records before the operation starts, preventing access by other operations.

```python
from django.db import transaction

def safe_follow(self, user):
    with transaction.atomic():
        # Lock users
        current_user = User.objects.select_for_update().get(id=self.id)
        target_user = User.objects.select_for_update().get(id=user.id)
        
        # F()-based updates first
        User.objects.filter(id=self.id).update(
            followed_number=F('followed_number') + 1
        )
        User.objects.filter(id=user.id).update(
            follower_number=F('follower_number') + 1
        )
        # Now create the follow relation
        self.follows.add(user)
```

**How It Works:**
- Records are locked with `select_for_update()`
- Other operations cannot read or write these records
- Lock remains until the transaction is complete
- Lock is released when the transaction ends

**Advantages:**
- Reliable and consistent
- Protection at the database level
- Suitable for complex operations

**Disadvantages:**
- Performance impact (wait times)
- Risk of deadlocks
- Throughput drops under high concurrency

⚠️ **Deadlock Example**: A classic deadlock scenario can occur if two transactions lock resources in different orders.

```python
# Deadlock scenario
# User A locks Account A, User B locks Account B, then both try to update each others accounts
from django.db import transaction

def transfer_between_accounts(account_a, account_b, amount):
    with transaction.atomic():
        acc_a = Account.objects.select_for_update().get(id=account_a)
        acc_b = Account.objects.select_for_update().get(id=account_b)
        # ... perform transfer ...
```

**How to Avoid:**
- Always acquire locks in a consistent order (e.g., by account ID)
- Keep transactions as short as possible
- Use database deadlock detection and handle exceptions gracefully

<img 
  src="/race4.jpg" 
  alt="F() expressions and atomic updates illustration" 
  className="w-full max-w-2xl mx-auto rounded-lg shadow-lg my-8"
/>

#### B. F() Expressions (Atomic Updates)

F() expressions allow you to perform atomic updates at the database level.

```python
from django.db.models import F

def atomic_follow(self, user):
    with transaction.atomic():
        # F()-based updates first
        User.objects.filter(id=self.id).update(
            followed_number=F('followed_number') + 1
        )
        User.objects.filter(id=user.id).update(
            follower_number=F('follower_number') + 1
        )
        # Now create the follow relation
        self.follows.add(user)
```

**How It Works:**
- Update is performed at the SQL level
- `UPDATE users SET followed_number = followed_number + 1 WHERE id = ?`
- The database performs the operation atomically
- No race condition occurs

**Advantages:**
- Very fast
- Safe against race conditions
- Minimal performance impact

**Disadvantages:**
- Only suitable for simple updates
- Not enough for complex operations

#### C. Unique Constraints

The safest way to check for unique fields is at the database level.

```python
class User(models.Model):
    username = models.CharField(max_length=50, unique=True)
    email = models.EmailField(unique=True)
    
    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=['username'], 
                name='unique_username'
            ),
            models.UniqueConstraint(
                fields=['email'], 
                name='unique_email'
            )
        ]

# Safe user creation
def safe_create_user(username, email):
    try:
        user = User.objects.create(username=username, email=email)
        return user
    except IntegrityError:
        raise ValidationError("Username or email already exists")
```

**Advantages:**
- Protection at the database level
- Full protection against race conditions
- No performance impact

### 2. Application-Level Solutions

#### A. Distributed Locking (Redis)

For production-grade distributed locking, consider using the redlock algorithm:

```python
from redlock import Redlock

# Setup Redlock with multiple Redis servers for high availability
redlock = Redlock([
    { 'host': 'localhost', 'port': 6379, 'db': 0 },
    # Add more Redis nodes if available
])

def safe_user_creation(username, email):
    lock = redlock.lock(f"user_creation:{username}:{email}", 10000)  # 10 seconds
    if lock:
        try:
            user = User.objects.create(username=username, email=email)
            return user
        except IntegrityError:
            raise ValidationError("User already exists")
        finally:
            redlock.unlock(lock)
    else:
        raise Exception("Could not acquire distributed lock. Please try again.")
```

**Advantages of Redlock:**
- Safer in distributed/multi-node environments
- Handles process crashes and network partitions more gracefully
- Can be tuned for high availability

<img 
  src="/race5.jpg" 
  alt="Optimistic locking illustration" 
  className="w-full max-w-sm mx-auto rounded-lg shadow-lg my-8"
/>

#### B. Optimistic Locking

In this method, records are not locked; instead, version control is used.

```python
# Recommended Library: pip install django-concurrency
from django_concurrency.fields import IntegerVersionField
from django_concurrency.exceptions import RecordModifiedError

class Product(models.Model):
    version = IntegerVersionField()
    product_title = models.CharField(max_length=100)

# Handling RecordModifiedError with Retry
def save_with_retry(instance, max_retries=3):
    for attempt in range(max_retries):
        try:
            instance.save()
            return
        except RecordModifiedError:
            if attempt == max_retries - 1:
                raise
            # Optionally reload the instance or merge changes
            instance.refresh_from_db()
            # Apply your changes again if needed
```

**Advantages:**
- Minimal performance impact
- No risk of deadlocks
- Suitable for read-heavy systems

**Disadvantages:**
- Retry mechanism is essential for reliability
- Not suitable for complex operations without careful merge logic
- May affect user experience if conflicts are frequent

### 3. Asynchronous Operations with Celery

We can reduce the risk of race conditions by making non-critical operations asynchronous.

```python
from celery import shared_task
from django.core.cache import cache

@shared_task(
    bind=True,
    max_retries=3,
    default_retry_delay=60,
    autoretry_for=(Exception,),
    retry_backoff=True,
    acks_late=True,
)
def update_user_stats(self, user_id):
    """Asynchronously update user statistics"""
    try:
        with transaction.atomic():
            user = User.objects.select_for_update().get(id=user_id)
            user.follower_number = user.followed_by.count()
            user.followed_number = user.follows.count()
            user.save()
            
            # Update cache
            cache.set(f"user_stats:{user_id}", {
                'followers': user.follower_number,
                'following': user.followed_number
            }, timeout=3600)
            
        return True
    except Exception as exc:
        logger.error(f"Error updating user stats for {user_id}: {exc}")
        raise self.retry(exc=exc)

def follow_with_async_update(self, user):
    """Follow operation + async stats update"""
    with transaction.atomic():
        self.follows.add(user)
    
    # Update stats asynchronously
    update_user_stats.delay(self.id)
    update_user_stats.delay(user.id)
```

**Advantages:**
- Main operation completes quickly
- Race condition risk is reduced
- System performance increases
- Retry mechanism

**Disadvantages:**
- Eventual consistency
- Complex error handling
- Monitoring required

---

## Best Practices and Recommendations

### 1. Database Transaction Management

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'ATOMIC_REQUESTS': False,  # For manual control
        'CONN_MAX_AGE': 60,
        'OPTIONS': {
            'connect_timeout': 10,
            'keepalives': 1,
            'keepalives_idle': 30,
            'keepalives_interval': 10,
            'keepalives_count': 5,
        },
    }
}

# views.py
from django.db import transaction

@transaction.atomic
def critical_operation(request):
    # Use transaction only for critical operations
    pass

def read_only_operation(request):
    # No need for transaction in read-only operations
    pass
```

### 2. Error Handling and Retry Mechanisms

```python
import time
from functools import wraps
from django.db import IntegrityError, TransactionManagementError

def retry_on_conflict(max_retries=3, delay=0.1):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except (IntegrityError, TransactionManagementError) as e:
                    if attempt == max_retries - 1:
                        raise
                    time.sleep(delay * (2 ** attempt))  # Exponential backoff
            return None
        return wrapper
    return decorator

# Usage
@retry_on_conflict(max_retries=3)
def create_user_with_retry(username, email):
    return User.objects.create(username=username, email=email)
```

### 3. Test Scenarios

```python
import threading
import time
from django.test import TestCase
from django.db import transaction

class RaceConditionTest(TestCase):
    def test_concurrent_follows(self):
        user1 = User.objects.create(username='user1', email='user1@test.com')
        user2 = User.objects.create(username='user2', email='user2@test.com')
        
        def follow_user():
            user1.follow(user2)
        
        # 10 threads follow at the same time
        threads = []
        for _ in range(10):
            thread = threading.Thread(target=follow_user)
            threads.append(thread)
            thread.start()
        
        for thread in threads:
            thread.join()
        
        # Check
        user1.refresh_from_db()
        user2.refresh_from_db()
        
        self.assertEqual(user1.followed_number, 1)
        self.assertEqual(user2.follower_number, 1)
```

---

## When Should You Use Which Solution?

**Simple Counter Updates:**
```python
# Use F() expressions
User.objects.filter(id=user_id).update(
    follower_number=F('follower_number') + 1
)
```

**Complex Operations:**
```python
# Use SELECT FOR UPDATE
with transaction.atomic():
    user = User.objects.select_for_update().get(id=user_id)
    # Complex operations...
```

**Uniqueness Checks:**
```python
# Use unique constraints
class User(models.Model):
    username = models.CharField(max_length=50, unique=True)
```

**High Concurrency:**
```python
# Use distributed locking (preferably with Redlock for multi-node setups)
from redlock import Redlock
# ...
```

---

## Conclusion

To prevent race conditions in Django:

- Use database-level solutions (SELECT FOR UPDATE, F() expressions)
- Define unique constraints
- Use distributed locking mechanisms (preferably Redlock for distributed setups)
- Use Celery for asynchronous operations
- Implement monitoring and logging
- Do comprehensive testing

Race conditions may seem complex, but with the right tools and approaches, they can be managed effectively. By leveraging Django's features, you can build reliable and performant applications.

**Remember:**
- Preventing race conditions is easier than fixing them
- Keep your test coverage high
- Continuously improve your monitoring system
- Always measure performance impact

By applying the techniques learned in this article, you can develop reliable, performant, and scalable Django applications.

---

### Resources

- [Django Transactions (Official Docs)](https://docs.djangoproject.com/en/stable/topics/db/transactions/)
- [Django F() Expressions (Official Docs)](https://docs.djangoproject.com/en/stable/ref/models/expressions/#f-expressions)
- [Django select_for_update() (Official Docs)](https://docs.djangoproject.com/en/stable/ref/models/querysets/#select-for-update)
- [PostgreSQL: Explicit Locking](https://www.postgresql.org/docs/current/explicit-locking.html)
- [Redis Distributed Locks (Official Docs)](https://redis.io/docs/manual/patterns/distributed-locks/)
- [Celery: Task Synchronization](https://docs.celeryproject.org/en/stable/userguide/tasks.html#task-synchronization)
- [Django Concurrency (PyPI)](https://pypi.org/project/django-concurrency/)
